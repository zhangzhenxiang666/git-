##### 2024-10-26

    如果修改了某个文件但是没有git add . 到缓存区，可以通过git restore`<file_name>` 或者git checkout -- `<file_name>` 撤销更改。

    但是当提交到缓存区后通过以上命令撤销不起作用，因为以上命令是把缓存区复制到工作区。要通过git restore --staged`<file_name>`撤销缓存区的修改, 或者通过git reset -- `<file_name>`恢复缓存区，也就是丢弃add到缓存区的状态。这个撤销缓存区更改是从本地仓库取最后一次的记录来覆盖当前的缓存区。

##### 2024-10-27

###### git设置忽略文件

创建 `.gitignore` 的文件，列出要忽略的文件模式

* 所有空行或者以注释符号"#"开头的行都会被 Git 忽略
* 可以使用标准的 glob 模式匹配
* 匹配模式最后跟斜杠(/)说明要忽略的是目录
* 要忽略指定模式以外的文件或目录，可以在模式前加上感叹号(!)进行取反

  ```
  "*"：星号匹配零个或多个任意字符。
  []：匹配任何一个列在方括号中的字符，如[ab]匹配a或者匹配b。
  "?"：问号匹配一个任意字符。
  [n-m]：匹配所有在这两个字符范围内的字符，如[0-9]表示匹配所有0到9的数字。
  logs/：忽略当前路径下的logs目录或多级路径下的logs目录，包含logs下的所有子目录和文件。 /logs.txt：忽略根目录下的logs.txt文件。
  *.class：忽略所有后缀为.class的文件。
  !/classes/a.class：不忽略classes目录下的a.class文件。
  tmp/*.txt：只忽略tmp目录下的.txt文件。
  **/foo：可以忽略/foo, a/foo, a/b/foo等。
  ```

###### git版本的回退

可以通过git reset命令回退版本, HEAD指向当前分支的最新提交(它会撤销提交记录)

```
git reset HEAD #可以将本地仓库的最后一次提交复制到缓存区
git reset HEAD^ #可以将本地仓库的倒数第二次提交复制到缓存区, 以此类推
git reset 版本号(前4位) # 将指定版本号的的版本复制到缓存区
git reset HEAD~0 #可以将本地仓库的最后一次提交复制到缓存区，以此类推
git reset --hard HEAD #可以将本地仓库的最后一次提交复制到缓存区和工作区
```

###### git撤销提交

可以通过上面的版本回退来撤销提交，也可以通过以下方式

```
git revert HEAD #将最后一次提交复制到缓存区和工作区，并且做一次新的提交(这也是不会撤销以前提交记录的原因)
git revert -n HEAD #将最后一次提交复制到缓存区和工作区，不做新的提交(需要自己手动提交)
```

###### git比较差异

通过git diff比较不同版本或者工作区和缓存区的差异

```
git diff #默认就是比较工作区和缓存区的差异
git diff <file> #比较指定文件工作区和缓存区的差异
git diff --cached #比较本地仓库最后一次提交与缓存区的差异
git diff <commit1> <commit2> #比较commit1和commit之间的差异
git diff HEAD #比较的本地仓库最后一次提交与工作区的差异
```

###### git远程仓库关联和管理

使用命令

```
git remote #查看本地已经配置的远程仓库
```

使用命令

```
git remote add <简称> url #用来关联远程仓库
```

使用命令

```
git pull <远程主机名> <远程分支名> #用来拉取文件
```

使用命令

```
git push <远程主机名> <本地分支名>:<远程分支名> #用来提交文件, 如果本地分支名与远程分支名相同，则可以省略冒号
```

使用命令

```
git remote rm 仓库名 #本地移除与远程仓库的关联，并不是将远程仓库从平台上删除。
```

使用命令

```
git fetch <远程名> #拉取远程仓库名但不会合并到工作区
```

使用命令

```
git merge <需要合并的分支名> #通过merge合并分支
```
